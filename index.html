
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image ‚Üî Hex Converter & Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 30px;
        }
        
        h1 {
            text-align: center;
            color: #667eea;
            margin-bottom: 30px;
            font-size: 2.5em;
        }
        
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
        }
        
        .tab {
            padding: 12px 24px;
            background: none;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            color: #666;
            transition: all 0.3s;
        }
        
        .tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
        }
        
        .tab:hover {
            color: #667eea;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 20px;
        }
        
        .upload-area:hover {
            background: #f8f9ff;
            border-color: #764ba2;
        }
        
        .upload-area.dragover {
            background: #e8ebff;
            border-color: #764ba2;
        }
        
        input[type="file"] {
            display: none;
        }
        
        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: transform 0.2s;
            margin: 5px;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .btn:active {
            transform: translateY(0);
        }
        
        .btn-secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }
        
        .btn-success {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }
        
        .canvas-container {
            display: flex;
            justify-content: center;
            margin: 20px 0;
            background: #f5f5f5;
            padding: 20px;
            border-radius: 10px;
            min-height: 400px;
            align-items: center;
        }
        
        canvas {
            max-width: 100%;
            border: 2px solid #ddd;
            border-radius: 5px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        
        video {
            transition: filter 0.3s, transform 0.3s;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .control-group {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }
        
        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }
        
        .control-group input[type="number"] {
            width: 100%;
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }
        
        .value-display {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 4px 12px;
            border-radius: 4px;
            font-weight: 600;
            margin-left: 10px;
        }
        
        .crop-controls {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin: 15px 0;
        }
        
        .crop-controls input {
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 5px;
        }
        
        textarea {
            width: 100%;
            min-height: 200px;
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            resize: vertical;
        }
        
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 15px 0;
            justify-content: center;
        }
        
        .info-box {
            background: #e8f4f8;
            border-left: 4px solid #4facfe;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        
        .warning-box {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        
        .hex-preview {
            background: #1e1e1e;
            color: #00ff00;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            max-height: 300px;
            overflow-y: auto;
            word-break: break-all;
            margin: 15px 0;
        }
        
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            border-radius: 5px;
            background: #ddd;
            outline: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé® Image ‚Üî Hex Converter & Editor</h1>
        
        <div class="tabs">
            <button class="tab active" onclick="switchTab('editor')">Image Editor</button>
            <button class="tab" onclick="switchTab('toHex')">Image ‚Üí Hex</button>
            <button class="tab" onclick="switchTab('toImage')">Hex ‚Üí Image</button>
            <button class="tab" onclick="switchTab('videoEditor')">Video Editor</button>
            <button class="tab" onclick="switchTab('videoToHex')">Video ‚Üí Hex</button>
            <button class="tab" onclick="switchTab('hexToVideo')">Hex ‚Üí Video</button>
            <button class="tab" onclick="switchTab('textToHex')">Text/Code ‚Üí Hex</button>
            <button class="tab" onclick="switchTab('hexToText')">Hex ‚Üí Text/Code</button>
        </div>
        
        <!-- Image Editor Tab -->
        <div id="editor" class="tab-content active">
            <div class="upload-area" id="uploadArea" onclick="document.getElementById('imageUpload').click()">
                <h2>üìÅ Upload or Drop Image Here</h2>
                <p>Supports: JPG, PNG, GIF, BMP, WEBP, SVG, ICO, and more</p>
            </div>
            <input type="file" id="imageUpload" accept="image/*">
            
            <div class="canvas-container">
                <canvas id="canvas"></canvas>
            </div>
            
            <div class="controls">
                <div class="control-group">
                    <label>Brightness <span class="value-display" id="brightnessValue">0</span></label>
                    <input type="range" id="brightness" min="-1000" max="1000" value="0" step="1">
                    <input type="number" id="brightnessNum" min="-1000" max="1000" value="0">
                </div>
                
                <div class="control-group">
                    <label>Contrast <span class="value-display" id="contrastValue">100</span></label>
                    <input type="range" id="contrast" min="-1000" max="1000" value="100" step="1">
                    <input type="number" id="contrastNum" min="-1000" max="1000" value="100">
                </div>
                
                <div class="control-group">
                    <label>Saturation <span class="value-display" id="saturationValue">100</span></label>
                    <input type="range" id="saturation" min="-1000" max="1000" value="100" step="1">
                    <input type="number" id="saturationNum" min="-1000" max="1000" value="100">
                </div>
                
                <div class="control-group">
                    <label>Hue Rotate <span class="value-display" id="hueValue">0</span>¬∞</label>
                    <input type="range" id="hue" min="-1000" max="1000" value="0" step="1">
                    <input type="number" id="hueNum" min="-1000" max="1000" value="0">
                </div>
                
                <div class="control-group">
                    <label>Blur <span class="value-display" id="blurValue">0</span>px</label>
                    <input type="range" id="blur" min="-1000" max="1000" value="0" step="1">
                    <input type="number" id="blurNum" min="-1000" max="1000" value="0">
                </div>
                
                <div class="control-group">
                    <label>Sharpness <span class="value-display" id="sharpnessValue">0</span></label>
                    <input type="range" id="sharpness" min="-1000" max="1000" value="0" step="1">
                    <input type="number" id="sharpnessNum" min="-1000" max="1000" value="0">
                </div>
                
                <div class="control-group">
                    <label>Sepia <span class="value-display" id="sepiaValue">0</span>%</label>
                    <input type="range" id="sepia" min="-1000" max="1000" value="0" step="1">
                    <input type="number" id="sepiaNum" min="-1000" max="1000" value="0">
                </div>
                
                <div class="control-group">
                    <label>Grayscale <span class="value-display" id="grayscaleValue">0</span>%</label>
                    <input type="range" id="grayscale" min="-1000" max="1000" value="0" step="1">
                    <input type="number" id="grayscaleNum" min="-1000" max="1000" value="0">
                </div>
                
                <div class="control-group">
                    <label>Invert <span class="value-display" id="invertValue">0</span>%</label>
                    <input type="range" id="invert" min="-1000" max="1000" value="0" step="1">
                    <input type="number" id="invertNum" min="-1000" max="1000" value="0">
                </div>
                
                <div class="control-group">
                    <label>Opacity <span class="value-display" id="opacityValue">100</span>%</label>
                    <input type="range" id="opacity" min="-1000" max="1000" value="100" step="1">
                    <input type="number" id="opacityNum" min="-1000" max="1000" value="100">
                </div>
                
                <div class="control-group">
                    <label>Red Channel <span class="value-display" id="redValue">0</span></label>
                    <input type="range" id="red" min="-1000" max="1000" value="0" step="1">
                    <input type="number" id="redNum" min="-1000" max="1000" value="0">
                </div>
                
                <div class="control-group">
                    <label>Green Channel <span class="value-display" id="greenValue">0</span></label>
                    <input type="range" id="green" min="-1000" max="1000" value="0" step="1">
                    <input type="number" id="greenNum" min="-1000" max="1000" value="0">
                </div>
                
                <div class="control-group">
                    <label>Blue Channel <span class="value-display" id="blueValue">0</span></label>
                    <input type="range" id="blue" min="-1000" max="1000" value="0" step="1">
                    <input type="number" id="blueNum" min="-1000" max="1000" value="0">
                </div>
                
                <div class="control-group">
                    <label>Exposure <span class="value-display" id="exposureValue">0</span></label>
                    <input type="range" id="exposure" min="-1000" max="1000" value="0" step="1">
                    <input type="number" id="exposureNum" min="-1000" max="1000" value="0">
                </div>
                
                <div class="control-group">
                    <label>Quality <span class="value-display" id="qualityValue">100</span>%</label>
                    <input type="range" id="quality" min="1" max="100" value="100" step="1">
                    <input type="number" id="qualityNum" min="1" max="100" value="100">
                </div>
            </div>
            
            <div class="control-group">
                <label>Crop Area (X, Y, Width, Height)</label>
                <div class="crop-controls">
                    <input type="number" id="cropX" placeholder="X" value="0">
                    <input type="number" id="cropY" placeholder="Y" value="0">
                    <input type="number" id="cropWidth" placeholder="Width">
                    <input type="number" id="cropHeight" placeholder="Height">
                </div>
                <button class="btn btn-secondary" onclick="applyCrop()">Apply Crop</button>
            </div>
            
            <div class="button-group">
                <button class="btn" onclick="resetFilters()">Reset All Filters</button>
                <button class="btn btn-secondary" onclick="rotateImage(90)">Rotate 90¬∞</button>
                <button class="btn btn-secondary" onclick="rotateImage(-90)">Rotate -90¬∞</button>
                <button class="btn btn-secondary" onclick="flipHorizontal()">Flip Horizontal</button>
                <button class="btn btn-secondary" onclick="flipVertical()">Flip Vertical</button>
                <button class="btn btn-success" onclick="downloadImage()">üíæ Download Image</button>
                <button class="btn btn-success" onclick="copyImageToClipboard()">üìã Copy to Clipboard</button>
            </div>
        </div>
        
        <!-- Image to Hex Tab -->
        <div id="toHex" class="tab-content">
            <div class="upload-area" id="uploadAreaHex" onclick="document.getElementById('imageUploadHex').click()">
                <h2>üìÅ Upload Image to Convert to Hex</h2>
                <p>Any image format supported</p>
            </div>
            <input type="file" id="imageUploadHex" accept="image/*">
            
            <div class="info-box">
                <strong>‚ÑπÔ∏è Info:</strong> The hex output is processed through character replacement for encoding.
            </div>
            
            <div class="button-group">
                <button class="btn btn-success" onclick="copyHexToClipboard()">üìã Copy Hex to Clipboard</button>
                <button class="btn btn-success" onclick="downloadHexFile()">üíæ Download as .txt</button>
            </div>
            
            <div class="hex-preview" id="hexPreview">Hex data will appear here...</div>
        </div>
        
        <!-- Hex to Image Tab -->
        <div id="toImage" class="tab-content">
            <div class="upload-area" id="uploadAreaTxt" onclick="document.getElementById('txtUpload').click()">
                <h2>üìÅ Upload Hex Text File</h2>
                <p>Upload a .txt file containing hex data</p>
            </div>
            <input type="file" id="txtUpload" accept=".txt">
            
            <div class="warning-box">
                <strong>‚ö†Ô∏è Note:</strong> The hex data will be decoded back to an image.
            </div>
            
            <label><strong>Or paste hex data here:</strong></label>
            <textarea id="hexInput" placeholder="Paste hex data here..."></textarea>
            
            <div class="button-group">
                <button class="btn" onclick="convertHexToImage()">üîÑ Convert Hex to Image</button>
            </div>
            
            <div class="canvas-container">
                <canvas id="canvasHexToImg"></canvas>
            </div>
            
            <div class="button-group">
                <button class="btn btn-success" onclick="downloadConvertedImage()">üíæ Download Image</button>
                <button class="btn btn-success" onclick="copyConvertedImageToClipboard()">üìã Copy to Clipboard</button>
            </div>
        </div>
        
        <!-- Video Editor Tab -->
        <div id="videoEditor" class="tab-content">
            <div class="upload-area" id="uploadAreaVideo" onclick="document.getElementById('videoUpload').click()">
                <h2>üé¨ Upload or Drop Video Here</h2>
                <p>Supports: MP4, WebM, MOV, AVI, MKV, and more</p>
            </div>
            <input type="file" id="videoUpload" accept="video/*">
            
            <div class="canvas-container" style="flex-direction: column; gap: 20px;">
                <video id="videoPlayer" controls style="max-width: 100%; max-height: 500px; border: 2px solid #ddd; border-radius: 5px;"></video>
                <canvas id="videoCanvas" style="display: none;"></canvas>
            </div>
            
            <div class="controls">
                <div class="control-group">
                    <label>Brightness <span class="value-display" id="vBrightnessValue">0</span></label>
                    <input type="range" id="vBrightness" min="-1000" max="1000" value="0" step="1">
                    <input type="number" id="vBrightnessNum" min="-1000" max="1000" value="0">
                </div>
                
                <div class="control-group">
                    <label>Contrast <span class="value-display" id="vContrastValue">100</span></label>
                    <input type="range" id="vContrast" min="-1000" max="1000" value="100" step="1">
                    <input type="number" id="vContrastNum" min="-1000" max="1000" value="100">
                </div>
                
                <div class="control-group">
                    <label>Saturation <span class="value-display" id="vSaturationValue">100</span></label>
                    <input type="range" id="vSaturation" min="-1000" max="1000" value="100" step="1">
                    <input type="number" id="vSaturationNum" min="-1000" max="1000" value="100">
                </div>
                
                <div class="control-group">
                    <label>Hue Rotate <span class="value-display" id="vHueValue">0</span>¬∞</label>
                    <input type="range" id="vHue" min="-1000" max="1000" value="0" step="1">
                    <input type="number" id="vHueNum" min="-1000" max="1000" value="0">
                </div>
                
                <div class="control-group">
                    <label>Blur <span class="value-display" id="vBlurValue">0</span>px</label>
                    <input type="range" id="vBlur" min="-1000" max="1000" value="0" step="1">
                    <input type="number" id="vBlurNum" min="-1000" max="1000" value="0">
                </div>
                
                <div class="control-group">
                    <label>Sepia <span class="value-display" id="vSepiaValue">0</span>%</label>
                    <input type="range" id="vSepia" min="-1000" max="1000" value="0" step="1">
                    <input type="number" id="vSepiaNum" min="-1000" max="1000" value="0">
                </div>
                
                <div class="control-group">
                    <label>Grayscale <span class="value-display" id="vGrayscaleValue">0</span>%</label>
                    <input type="range" id="vGrayscale" min="-1000" max="1000" value="0" step="1">
                    <input type="number" id="vGrayscaleNum" min="-1000" max="1000" value="0">
                </div>
                
                <div class="control-group">
                    <label>Invert <span class="value-display" id="vInvertValue">0</span>%</label>
                    <input type="range" id="vInvert" min="-1000" max="1000" value="0" step="1">
                    <input type="number" id="vInvertNum" min="-1000" max="1000" value="0">
                </div>
                
                <div class="control-group">
                    <label>Opacity <span class="value-display" id="vOpacityValue">100</span>%</label>
                    <input type="range" id="vOpacity" min="-1000" max="1000" value="100" step="1">
                    <input type="number" id="vOpacityNum" min="-1000" max="1000" value="100">
                </div>
                
                <div class="control-group">
                    <label>Playback Speed <span class="value-display" id="vSpeedValue">1.0</span>x</label>
                    <input type="range" id="vSpeed" min="0.1" max="10" value="1" step="0.1">
                    <input type="number" id="vSpeedNum" min="0.1" max="10" value="1" step="0.1">
                </div>
            </div>
            
            <div class="button-group">
                <button class="btn" onclick="resetVideoFilters()">Reset All Filters</button>
                <button class="btn btn-secondary" onclick="rotateVideo(90)">Rotate 90¬∞</button>
                <button class="btn btn-secondary" onclick="rotateVideo(-90)">Rotate -90¬∞</button>
                <button class="btn btn-secondary" onclick="flipVideoHorizontal()">Flip Horizontal</button>
                <button class="btn btn-secondary" onclick="flipVideoVertical()">Flip Vertical</button>
                <button class="btn btn-success" onclick="downloadVideo()">üíæ Download Video (Processing...)</button>
            </div>
        </div>
        
        <!-- Video to Hex Tab -->
        <div id="videoToHex" class="tab-content">
            <div class="upload-area" id="uploadAreaVideoHex" onclick="document.getElementById('videoUploadHex').click()">
                <h2>üé¨ Upload Video to Convert to Hex</h2>
                <p>Any video format supported</p>
            </div>
            <input type="file" id="videoUploadHex" accept="video/*">
            
            <div class="info-box">
                <strong>‚ÑπÔ∏è Info:</strong> The hex output is processed through character replacement for encoding.
            </div>
            
            <div class="warning-box">
                <strong>‚ö†Ô∏è Note:</strong> Large videos may take time to process and generate large hex files.
            </div>
            
            <div id="videoHexProgress" style="display: none; margin: 15px 0;">
                <div style="background: #e0e0e0; border-radius: 10px; overflow: hidden; height: 30px;">
                    <div id="videoHexProgressBar" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); height: 100%; width: 0%; transition: width 0.3s; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;"></div>
                </div>
            </div>
            
            <div class="button-group">
                <button class="btn btn-success" onclick="copyVideoHexToClipboard()">üìã Copy Hex to Clipboard</button>
                <button class="btn btn-success" onclick="downloadVideoHexFile()">üíæ Download as .txt</button>
            </div>
            
            <div class="hex-preview" id="videoHexPreview">Hex data will appear here...</div>
        </div>
        
        <!-- Hex to Video Tab -->
        <div id="hexToVideo" class="tab-content">
            <div class="upload-area" id="uploadAreaVideoTxt" onclick="document.getElementById('videoTxtUpload').click()">
                <h2>üìÅ Upload Hex Text File</h2>
                <p>Upload a .txt file containing video hex data</p>
            </div>
            <input type="file" id="videoTxtUpload" accept=".txt">
            
            <div class="warning-box">
                <strong>‚ö†Ô∏è Note:</strong> The hex data will be decoded back to a video.
            </div>
            
            <label><strong>Or paste hex data here:</strong></label>
            <textarea id="videoHexInput" placeholder="Paste hex data here..."></textarea>
            
            <div class="button-group">
                <button class="btn" onclick="convertHexToVideo()">üîÑ Convert Hex to Video</button>
            </div>
            
            <div class="canvas-container">
                <video id="videoPlayerConverted" controls style="max-width: 100%; max-height: 500px; border: 2px solid #ddd; border-radius: 5px;"></video>
            </div>
            
            <div class="button-group">
                <button class="btn btn-success" onclick="downloadConvertedVideo()">üíæ Download Video</button>
            </div>
        </div>
        
        <!-- Text/Code to Hex Tab -->
        <div id="textToHex" class="tab-content">
            <div class="upload-area" id="uploadAreaText" onclick="document.getElementById('textFileUpload').click()">
                <h2>üìÑ Upload Text/Code File</h2>
                <p>Supports: .txt, .js, .py, .html, .css, .json, .xml, .md, .cpp, .java, and more</p>
            </div>
            <input type="file" id="textFileUpload" accept=".txt,.js,.py,.html,.css,.json,.xml,.md,.cpp,.java,.c,.h,.jsx,.tsx,.vue,.php,.rb,.go,.rs,.swift,.kt,.scala,.sh,.bat,.yml,.yaml,.toml,.ini,.cfg,.conf">
            
            <label><strong>Or paste/type your text or code here:</strong></label>
            <textarea id="textInput" placeholder="Paste or type your text, code, or any content here..." style="min-height: 300px; font-family: 'Courier New', monospace;"></textarea>
            
            <div class="info-box">
                <strong>‚ÑπÔ∏è Info:</strong> Your text/code will be converted to hex with advanced character replacement encoding. Perfect for obfuscating source code, notes, or any text data.
            </div>
            
            <div class="button-group">
                <button class="btn" onclick="convertTextToHex()">üîÑ Convert to Hex</button>
                <button class="btn btn-success" onclick="copyTextHexToClipboard()">üìã Copy Hex to Clipboard</button>
                <button class="btn btn-success" onclick="downloadTextHexFile()">üíæ Download as .txt</button>
            </div>
            
            <div class="hex-preview" id="textHexPreview">Hex data will appear here...</div>
        </div>
        
        <!-- Hex to Text/Code Tab -->
        <div id="hexToText" class="tab-content">
            <div class="upload-area" id="uploadAreaHexText" onclick="document.getElementById('hexTextFileUpload').click()">
                <h2>üìÅ Upload Hex Text File</h2>
                <p>Upload a .txt file containing encoded hex data</p>
            </div>
            <input type="file" id="hexTextFileUpload" accept=".txt">
            
            <div class="warning-box">
                <strong>‚ö†Ô∏è Note:</strong> The hex data will be decoded back to readable text/code.
            </div>
            
            <label><strong>Or paste hex data here:</strong></label>
            <textarea id="hexToTextInput" placeholder="Paste encoded hex data here..." style="min-height: 200px;"></textarea>
            
            <div class="button-group">
                <button class="btn" onclick="convertHexToText()">üîÑ Convert Hex to Text</button>
                <button class="btn btn-success" onclick="copyDecodedText()">üìã Copy Text to Clipboard</button>
                <button class="btn btn-success" onclick="downloadDecodedText()">üíæ Download as .txt</button>
            </div>
            
            <label><strong>Decoded Text/Code:</strong></label>
            <textarea id="decodedTextOutput" placeholder="Decoded text will appear here..." style="min-height: 300px; font-family: 'Courier New', monospace;" readonly></textarea>
        </div>
    </div>

    <script>
        // Global variables
        let originalImage = null;
        let canvas = document.getElementById('canvas');
        let ctx = canvas.getContext('2d');
        let currentRotation = 0;
        let currentFlipH = 1;
        let currentFlipV = 1;
        let hexData = '';

        // Tab switching
        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            document.querySelector(`button[onclick="switchTab('${tabName}')"]`).classList.add('active');
            document.getElementById(tabName).classList.add('active');
        }

        // Drag and drop for main editor
        const uploadArea = document.getElementById('uploadArea');
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('image/')) {
                loadImage(file);
            }
        });

        // Image upload for editor
        document.getElementById('imageUpload').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) loadImage(file);
        });

        // Load image
        function loadImage(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    originalImage = img;
                    canvas.width = img.width;
                    canvas.height = img.height;
                    document.getElementById('cropWidth').value = img.width;
                    document.getElementById('cropHeight').value = img.height;
                    applyFilters();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // Sync sliders with number inputs
        const filters = ['brightness', 'contrast', 'saturation', 'hue', 'blur', 'sharpness', 
                        'sepia', 'grayscale', 'invert', 'opacity', 'red', 'green', 'blue', 'exposure', 'quality'];
        
        filters.forEach(filter => {
            const slider = document.getElementById(filter);
            const numInput = document.getElementById(filter + 'Num');
            const valueDisplay = document.getElementById(filter + 'Value');
            
            slider.addEventListener('input', () => {
                numInput.value = slider.value;
                valueDisplay.textContent = slider.value + (filter === 'quality' ? '%' : '');
                applyFilters();
            });
            
            numInput.addEventListener('input', () => {
                slider.value = numInput.value;
                valueDisplay.textContent = numInput.value + (filter === 'quality' ? '%' : '');
                applyFilters();
            });
        });

        // Apply all filters
        function applyFilters() {
            if (!originalImage) return;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            
            // Apply transformations
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.rotate(currentRotation * Math.PI / 180);
            ctx.scale(currentFlipH, currentFlipV);
            ctx.translate(-canvas.width / 2, -canvas.height / 2);
            
            // Apply CSS filters
            const brightness = parseInt(document.getElementById('brightness').value);
            const contrast = parseInt(document.getElementById('contrast').value);
            const saturation = parseInt(document.getElementById('saturation').value);
            const hue = parseInt(document.getElementById('hue').value);
            const blur = parseInt(document.getElementById('blur').value);
            const sepia = parseInt(document.getElementById('sepia').value);
            const grayscale = parseInt(document.getElementById('grayscale').value);
            const invert = parseInt(document.getElementById('invert').value);
            const opacity = parseInt(document.getElementById('opacity').value);
            
            ctx.filter = `
                brightness(${100 + brightness}%)
                contrast(${contrast}%)
                saturate(${saturation}%)
                hue-rotate(${hue}deg)
                blur(${Math.max(0, blur)}px)
                sepia(${Math.max(0, sepia)}%)
                grayscale(${Math.max(0, grayscale)}%)
                invert(${Math.max(0, invert)}%)
                opacity(${Math.max(0, Math.min(100, opacity))}%)
            `;
            
            ctx.drawImage(originalImage, 0, 0);
            ctx.restore();
            
            // Apply pixel-level adjustments
            applyPixelAdjustments();
        }

        // Apply pixel-level adjustments
        function applyPixelAdjustments() {
            const sharpness = parseInt(document.getElementById('sharpness').value);
            const red = parseInt(document.getElementById('red').value);
            const green = parseInt(document.getElementById('green').value);
            const blue = parseInt(document.getElementById('blue').value);
            const exposure = parseInt(document.getElementById('exposure').value);
            const quality = parseInt(document.getElementById('quality').value);
            
            if (sharpness === 0 && red === 0 && green === 0 && blue === 0 && exposure === 0 && quality === 100) return;
            
            let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            let data = imageData.data;
            
            // Apply sharpness
            if (sharpness !== 0) {
                imageData = applySharpen(imageData, sharpness / 100);
                data = imageData.data;
            }
            
            // Apply quality reduction (compression artifact simulation)
            if (quality < 100) {
                imageData = applyQualityReduction(imageData, quality);
                data = imageData.data;
            }
            
            // Apply color channel and exposure adjustments
            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.max(0, Math.min(255, data[i] + red + exposure));     // Red
                data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + green + exposure)); // Green
                data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + blue + exposure));  // Blue
            }
            
            ctx.putImageData(imageData, 0, 0);
        }

        // Sharpen filter
        function applySharpen(imageData, amount) {
            const pixels = imageData.data;
            const width = imageData.width;
            const height = imageData.height;
            const output = new Uint8ClampedArray(pixels);
            
            const kernel = [
                0, -amount, 0,
                -amount, 1 + 4 * amount, -amount,
                0, -amount, 0
            ];
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    for (let c = 0; c < 3; c++) {
                        let sum = 0;
                        for (let ky = -1; ky <= 1; ky++) {
                            for (let kx = -1; kx <= 1; kx++) {
                                const idx = ((y + ky) * width + (x + kx)) * 4 + c;
                                const kidx = (ky + 1) * 3 + (kx + 1);
                                sum += pixels[idx] * kernel[kidx];
                            }
                        }
                        const idx = (y * width + x) * 4 + c;
                        output[idx] = Math.max(0, Math.min(255, sum));
                    }
                }
            }
            
            return new ImageData(output, width, height);
        }

        // Quality reduction filter (simulates compression artifacts and pixelation)
        function applyQualityReduction(imageData, quality) {
            const pixels = imageData.data;
            const width = imageData.width;
            const height = imageData.height;
            const output = new Uint8ClampedArray(pixels);
            
            // Calculate block size based on quality (lower quality = larger blocks)
            const blockSize = Math.max(1, Math.floor((101 - quality) / 10));
            
            // Color quantization levels (lower quality = fewer colors)
            const colorLevels = Math.max(2, Math.floor(quality * 2.55));
            
            // Apply block averaging (pixelation effect)
            for (let y = 0; y < height; y += blockSize) {
                for (let x = 0; x < width; x += blockSize) {
                    let rSum = 0, gSum = 0, bSum = 0, aSum = 0;
                    let count = 0;
                    
                    // Average the block
                    for (let by = 0; by < blockSize && y + by < height; by++) {
                        for (let bx = 0; bx < blockSize && x + bx < width; bx++) {
                            const idx = ((y + by) * width + (x + bx)) * 4;
                            rSum += pixels[idx];
                            gSum += pixels[idx + 1];
                            bSum += pixels[idx + 2];
                            aSum += pixels[idx + 3];
                            count++;
                        }
                    }
                    
                    // Calculate average
                    const rAvg = rSum / count;
                    const gAvg = gSum / count;
                    const bAvg = bSum / count;
                    const aAvg = aSum / count;
                    
                    // Quantize colors
                    const rQuant = Math.round(rAvg / 255 * colorLevels) * (255 / colorLevels);
                    const gQuant = Math.round(gAvg / 255 * colorLevels) * (255 / colorLevels);
                    const bQuant = Math.round(bAvg / 255 * colorLevels) * (255 / colorLevels);
                    
                    // Apply to all pixels in the block
                    for (let by = 0; by < blockSize && y + by < height; by++) {
                        for (let bx = 0; bx < blockSize && x + bx < width; bx++) {
                            const idx = ((y + by) * width + (x + bx)) * 4;
                            output[idx] = rQuant;
                            output[idx + 1] = gQuant;
                            output[idx + 2] = bQuant;
                            output[idx + 3] = aAvg;
                        }
                    }
                }
            }
            
            return new ImageData(output, width, height);
        }

        // Rotation
        function rotateImage(degrees) {
            currentRotation = (currentRotation + degrees) % 360;
            if (degrees === 90 || degrees === -90 || degrees === 270 || degrees === -270) {
                [canvas.width, canvas.height] = [canvas.height, canvas.width];
            }
            applyFilters();
        }

        // Flip
        function flipHorizontal() {
            currentFlipH *= -1;
            applyFilters();
        }

        function flipVertical() {
            currentFlipV *= -1;
            applyFilters();
        }

        // Crop
        function applyCrop() {
            const x = parseInt(document.getElementById('cropX').value) || 0;
            const y = parseInt(document.getElementById('cropY').value) || 0;
            const width = parseInt(document.getElementById('cropWidth').value) || canvas.width;
            const height = parseInt(document.getElementById('cropHeight').value) || canvas.height;
            
            const imageData = ctx.getImageData(x, y, width, height);
            canvas.width = width;
            canvas.height = height;
            ctx.putImageData(imageData, 0, 0);
            
            // Update original image
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = width;
            tempCanvas.height = height;
            tempCanvas.getContext('2d').putImageData(imageData, 0, 0);
            
            const img = new Image();
            img.onload = () => {
                originalImage = img;
                applyFilters();
            };
            img.src = tempCanvas.toDataURL();
        }

        // Reset filters
        function resetFilters() {
            filters.forEach(filter => {
                let defaultVal = 0;
                if (filter === 'contrast' || filter === 'saturation' || filter === 'opacity') {
                    defaultVal = 100;
                } else if (filter === 'quality') {
                    defaultVal = 100;
                }
                document.getElementById(filter).value = defaultVal;
                document.getElementById(filter + 'Num').value = defaultVal;
                const suffix = filter === 'quality' ? '%' : '';
                document.getElementById(filter + 'Value').textContent = defaultVal + suffix;
            });
            currentRotation = 0;
            currentFlipH = 1;
            currentFlipV = 1;
            if (originalImage) {
                canvas.width = originalImage.width;
                canvas.height = originalImage.height;
            }
            applyFilters();
        }

        // Download image
        function downloadImage() {
            const quality = parseInt(document.getElementById('quality').value) / 100;
            const link = document.createElement('a');
            link.download = 'edited-image.png';
            
            // If quality is less than 100, export as JPEG with quality setting
            if (quality < 1) {
                link.href = canvas.toDataURL('image/jpeg', quality);
                link.download = 'edited-image.jpg';
            } else {
                link.href = canvas.toDataURL('image/png');
            }
            link.click();
        }

        // Copy to clipboard
        async function copyImageToClipboard() {
            try {
                const blob = await new Promise(resolve => canvas.toBlob(resolve));
                await navigator.clipboard.write([
                    new ClipboardItem({ 'image/png': blob })
                ]);
                alert('Image copied to clipboard!');
            } catch (err) {
                alert('Failed to copy image to clipboard');
            }
        }

        // IMAGE TO HEX CONVERSION
        document.getElementById('imageUploadHex').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) convertImageToHex(file);
        });

        function convertImageToHex(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const arrayBuffer = e.target.result;
                const bytes = new Uint8Array(arrayBuffer);
                let hex = '';
                
                for (let i = 0; i < bytes.length; i++) {
                    hex += bytes[i].toString(16).padStart(2, '0');
                }
                
                // Apply character replacement (encoding)
                hexData = encodeHex(hex);
                document.getElementById('hexPreview').textContent = hexData.substring(0, 5000) + (hexData.length > 5000 ? '...' : '');
            };
            reader.readAsArrayBuffer(file);
        }

        // Encode hex with complex character replacement
        function encodeHex(hex) {
            // First pass: replace single hex chars
            let encoded = hex
                .replace(/0/g, '%')
                .replace(/1/g, '#')
                .replace(/2/g, '@')
                .replace(/3/g, '&')
                .replace(/4/g, '!')
                .replace(/5/g, '^')
                .replace(/6/g, '(')
                .replace(/7/g, ')')
                .replace(/8/g, '[')
                .replace(/9/g, '‚â£')
                .replace(/a/g, '/')
                .replace(/b/g, '\\')
                .replace(/c/g, '~')
                .replace(/d/g, '`')
                .replace(/e/g, '$')
                .replace(/f/g, '*');
            
            // Second pass: replace pairs for multi-char encoding with combining marks
            // Using combining diacritical marks (U+0300 to U+036F range, encoded as %CC%80 to %CC%AF)
            encoded = encoded
                .replace(/%%/g, 'a\u0300')  // 00 -> a with combining grave
                .replace(/#%/g, 'e\u0301')  // 10 -> e with combining acute
                .replace(/@%/g, 'i\u0302')  // 20 -> i with combining circumflex
                .replace(/&%/g, 'o\u0303')  // 30 -> o with combining tilde
                .replace(/!%/g, 'u\u0304')  // 40 -> u with combining macron
                .replace(/\^%/g, 'n\u0308')  // 50 -> n with combining diaeresis
                .replace(/\(%/g, 's\u030A')  // 60 -> s with combining ring above
                .replace(/\)%/g, 'c\u030C')  // 70 -> c with combining caron
                .replace(/\[%/g, 'y\u0307')  // 80 -> y with combining dot above
                .replace(/‚â£%/g, 'z\u0306')  // 90 -> z with combining breve
                .replace(/\/%/g, '‚Ç°')       // a0 -> colon currency
                .replace(/\\%/g, '‚éØ')       // b0 -> horizontal line
                .replace(/~%/g, '‚≠ó')        // c0 -> diamond arrow
                .replace(/`%/g, 'w\u0311')  // d0 -> w with combining inverted breve
                .replace(/\$%/g, 'r\u0323')  // e0 -> r with combining dot below
                .replace(/\*%/g, 't\u0327'); // f0 -> t with combining cedilla
            
            return encoded;
        }

        // Decode hex with complex character replacement
        function decodeHex(encoded) {
            // First pass: decode multi-char sequences back to pairs
            let decoded = encoded
                .replace(/a\u0300/g, '%%')  // a with combining grave -> 00
                .replace(/e\u0301/g, '#%')  // e with combining acute -> 10
                .replace(/i\u0302/g, '@%')  // i with combining circumflex -> 20
                .replace(/o\u0303/g, '&%')  // o with combining tilde -> 30
                .replace(/u\u0304/g, '!%')  // u with combining macron -> 40
                .replace(/n\u0308/g, '^%')  // n with combining diaeresis -> 50
                .replace(/s\u030A/g, '(%')  // s with combining ring above -> 60
                .replace(/c\u030C/g, ')%')  // c with combining caron -> 70
                .replace(/y\u0307/g, '[%')  // y with combining dot above -> 80
                .replace(/z\u0306/g, '‚â£%')  // z with combining breve -> 90
                .replace(/‚Ç°/g, '/%')        // colon currency -> a0
                .replace(/‚éØ/g, '\\%')       // horizontal line -> b0
                .replace(/‚≠ó/g, '~%')        // diamond arrow -> c0
                .replace(/w\u0311/g, '`%')  // w with combining inverted breve -> d0
                .replace(/r\u0323/g, '$%')  // r with combining dot below -> e0
                .replace(/t\u0327/g, '*%'); // t with combining cedilla -> f0
            
            // Second pass: decode single chars
            decoded = decoded
                .replace(/%/g, '0')
                .replace(/#/g, '1')
                .replace(/@/g, '2')
                .replace(/&/g, '3')
                .replace(/!/g, '4')
                .replace(/\^/g, '5')
                .replace(/\(/g, '6')
                .replace(/\)/g, '7')
                .replace(/\[/g, '8')
                .replace(/‚â£/g, '9')
                .replace(/\//g, 'a')
                .replace(/\\/g, 'b')
                .replace(/~/g, 'c')
                .replace(/`/g, 'd')
                .replace(/\$/g, 'e')
                .replace(/\*/g, 'f');
            
            return decoded;
        }

        function copyHexToClipboard() {
            navigator.clipboard.writeText(hexData).then(() => {
                alert('Hex data copied to clipboard!');
            });
        }

        function downloadHexFile() {
            const blob = new Blob([hexData], { type: 'text/plain' });
            const link = document.createElement('a');
            link.download = 'image-hex.txt';
            link.href = URL.createObjectURL(blob);
            link.click();
        }

        // HEX TO IMAGE CONVERSION
        document.getElementById('txtUpload').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    document.getElementById('hexInput').value = e.target.result;
                };
                reader.readAsText(file);
            }
        });

        function convertHexToImage() {
            const encodedHex = document.getElementById('hexInput').value.trim();
            if (!encodedHex) {
                alert('Please paste or upload hex data');
                return;
            }
            
            // Decode the hex
            const hex = decodeHex(encodedHex);
            
            // Convert hex to bytes
            const bytes = new Uint8Array(hex.length / 2);
            for (let i = 0; i < hex.length; i += 2) {
                bytes[i / 2] = parseInt(hex.substr(i, 2), 16);
            }
            
            // Create blob and load image
            const blob = new Blob([bytes]);
            const url = URL.createObjectURL(blob);
            const img = new Image();
            const canvasHex = document.getElementById('canvasHexToImg');
            const ctxHex = canvasHex.getContext('2d');
            
            img.onload = () => {
                canvasHex.width = img.width;
                canvasHex.height = img.height;
                ctxHex.drawImage(img, 0, 0);
                URL.revokeObjectURL(url);
            };
            img.onerror = () => {
                alert('Failed to convert hex to image. Invalid data.');
            };
            img.src = url;
        }

        function downloadConvertedImage() {
            const canvasHex = document.getElementById('canvasHexToImg');
            const link = document.createElement('a');
            link.download = 'converted-image.png';
            link.href = canvasHex.toDataURL();
            link.click();
        }

        async function copyConvertedImageToClipboard() {
            try {
                const canvasHex = document.getElementById('canvasHexToImg');
                const blob = await new Promise(resolve => canvasHex.toBlob(resolve));
                await navigator.clipboard.write([
                    new ClipboardItem({ 'image/png': blob })
                ]);
                alert('Image copied to clipboard!');
            } catch (err) {
                alert('Failed to copy image to clipboard');
            }
        }
        
        // ============================================
        // VIDEO EDITOR FUNCTIONALITY
        // ============================================
        
        let videoElement = document.getElementById('videoPlayer');
        let videoCanvas = document.getElementById('videoCanvas');
        let videoCtx = videoCanvas.getContext('2d');
        let currentVideoRotation = 0;
        let currentVideoFlipH = 1;
        let currentVideoFlipV = 1;
        let videoHexData = '';
        let currentVideoFile = null;
        
        // Video upload for editor
        document.getElementById('videoUpload').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) loadVideo(file);
        });
        
        // Drag and drop for video editor
        const uploadAreaVideo = document.getElementById('uploadAreaVideo');
        uploadAreaVideo.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadAreaVideo.classList.add('dragover');
        });
        uploadAreaVideo.addEventListener('dragleave', () => {
            uploadAreaVideo.classList.remove('dragover');
        });
        uploadAreaVideo.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadAreaVideo.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('video/')) {
                loadVideo(file);
            }
        });
        
        // Load video
        function loadVideo(file) {
            currentVideoFile = file;
            const url = URL.createObjectURL(file);
            videoElement.src = url;
            videoElement.load();
        }
        
        // Sync video sliders with number inputs
        const videoFilters = ['vBrightness', 'vContrast', 'vSaturation', 'vHue', 'vBlur', 
                             'vSepia', 'vGrayscale', 'vInvert', 'vOpacity', 'vSpeed'];
        
        videoFilters.forEach(filter => {
            const slider = document.getElementById(filter);
            const numInput = document.getElementById(filter + 'Num');
            const valueDisplay = document.getElementById(filter + 'Value');
            
            slider.addEventListener('input', () => {
                numInput.value = slider.value;
                valueDisplay.textContent = slider.value + (filter === 'vSpeed' ? 'x' : '');
                applyVideoFilters();
            });
            
            numInput.addEventListener('input', () => {
                slider.value = numInput.value;
                valueDisplay.textContent = numInput.value + (filter === 'vSpeed' ? 'x' : '');
                applyVideoFilters();
            });
        });
        
        // Apply video filters
        function applyVideoFilters() {
            const brightness = parseInt(document.getElementById('vBrightness').value);
            const contrast = parseInt(document.getElementById('vContrast').value);
            const saturation = parseInt(document.getElementById('vSaturation').value);
            const hue = parseInt(document.getElementById('vHue').value);
            const blur = parseInt(document.getElementById('vBlur').value);
            const sepia = parseInt(document.getElementById('vSepia').value);
            const grayscale = parseInt(document.getElementById('vGrayscale').value);
            const invert = parseInt(document.getElementById('vInvert').value);
            const opacity = parseInt(document.getElementById('vOpacity').value);
            const speed = parseFloat(document.getElementById('vSpeed').value);
            
            let transform = '';
            if (currentVideoRotation !== 0) {
                transform += `rotate(${currentVideoRotation}deg) `;
            }
            if (currentVideoFlipH === -1) {
                transform += 'scaleX(-1) ';
            }
            if (currentVideoFlipV === -1) {
                transform += 'scaleY(-1) ';
            }
            
            videoElement.style.filter = `
                brightness(${100 + brightness}%)
                contrast(${contrast}%)
                saturate(${saturation}%)
                hue-rotate(${hue}deg)
                blur(${Math.max(0, blur)}px)
                sepia(${Math.max(0, sepia)}%)
                grayscale(${Math.max(0, grayscale)}%)
                invert(${Math.max(0, invert)}%)
                opacity(${Math.max(0, Math.min(100, opacity))}%)
            `;
            
            videoElement.style.transform = transform;
            videoElement.playbackRate = speed;
        }
        
        // Reset video filters
        function resetVideoFilters() {
            document.getElementById('vBrightness').value = 0;
            document.getElementById('vBrightnessNum').value = 0;
            document.getElementById('vBrightnessValue').textContent = 0;
            
            document.getElementById('vContrast').value = 100;
            document.getElementById('vContrastNum').value = 100;
            document.getElementById('vContrastValue').textContent = 100;
            
            document.getElementById('vSaturation').value = 100;
            document.getElementById('vSaturationNum').value = 100;
            document.getElementById('vSaturationValue').textContent = 100;
            
            document.getElementById('vHue').value = 0;
            document.getElementById('vHueNum').value = 0;
            document.getElementById('vHueValue').textContent = 0;
            
            document.getElementById('vBlur').value = 0;
            document.getElementById('vBlurNum').value = 0;
            document.getElementById('vBlurValue').textContent = 0;
            
            document.getElementById('vSepia').value = 0;
            document.getElementById('vSepiaNum').value = 0;
            document.getElementById('vSepiaValue').textContent = 0;
            
            document.getElementById('vGrayscale').value = 0;
            document.getElementById('vGrayscaleNum').value = 0;
            document.getElementById('vGrayscaleValue').textContent = 0;
            
            document.getElementById('vInvert').value = 0;
            document.getElementById('vInvertNum').value = 0;
            document.getElementById('vInvertValue').textContent = 0;
            
            document.getElementById('vOpacity').value = 100;
            document.getElementById('vOpacityNum').value = 100;
            document.getElementById('vOpacityValue').textContent = 100;
            
            document.getElementById('vSpeed').value = 1;
            document.getElementById('vSpeedNum').value = 1;
            document.getElementById('vSpeedValue').textContent = '1.0x';
            
            currentVideoRotation = 0;
            currentVideoFlipH = 1;
            currentVideoFlipV = 1;
            
            applyVideoFilters();
        }
        
        // Rotate video
        function rotateVideo(degrees) {
            currentVideoRotation = (currentVideoRotation + degrees) % 360;
            applyVideoFilters();
        }
        
        // Flip video
        function flipVideoHorizontal() {
            currentVideoFlipH *= -1;
            applyVideoFilters();
        }
        
        function flipVideoVertical() {
            currentVideoFlipV *= -1;
            applyVideoFilters();
        }
        
        // Download video with filters applied
        async function downloadVideo() {
            if (!currentVideoFile) {
                alert('Please upload a video first');
                return;
            }
            
            alert('Video processing started! This may take a while depending on video length. The browser may appear frozen - please wait...');
            
            try {
                // For now, we'll use a simpler approach: download with current filters applied visually
                // Full video re-encoding would require FFmpeg.js which is complex
                const link = document.createElement('a');
                link.download = 'filtered-video.mp4';
                link.href = URL.createObjectURL(currentVideoFile);
                link.click();
                
                alert('Note: This downloads the original video. For filters to be permanently applied, browser-based video encoding would require additional libraries. The filters are applied for playback only.');
            } catch (err) {
                alert('Error downloading video: ' + err.message);
            }
        }
        
        // VIDEO TO HEX CONVERSION
        document.getElementById('videoUploadHex').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) convertVideoToHex(file);
        });
        
        function convertVideoToHex(file) {
            document.getElementById('videoHexProgress').style.display = 'block';
            document.getElementById('videoHexProgressBar').style.width = '0%';
            document.getElementById('videoHexProgressBar').textContent = '0%';
            
            const reader = new FileReader();
            reader.onprogress = (e) => {
                if (e.lengthComputable) {
                    const percent = Math.round((e.loaded / e.total) * 100);
                    document.getElementById('videoHexProgressBar').style.width = percent + '%';
                    document.getElementById('videoHexProgressBar').textContent = percent + '%';
                }
            };
            
            reader.onload = (e) => {
                const arrayBuffer = e.target.result;
                const bytes = new Uint8Array(arrayBuffer);
                let hex = '';
                
                // Convert to hex in chunks to avoid memory issues
                const chunkSize = 1024 * 1024; // 1MB chunks
                for (let i = 0; i < bytes.length; i += chunkSize) {
                    const chunk = bytes.slice(i, Math.min(i + chunkSize, bytes.length));
                    for (let j = 0; j < chunk.length; j++) {
                        hex += chunk[j].toString(16).padStart(2, '0');
                    }
                }
                
                // Apply character replacement (encoding)
                videoHexData = encodeHex(hex);
                document.getElementById('videoHexPreview').textContent = 
                    videoHexData.substring(0, 5000) + (videoHexData.length > 5000 ? '...\n\n[' + videoHexData.length + ' total characters]' : '');
                
                document.getElementById('videoHexProgressBar').style.width = '100%';
                document.getElementById('videoHexProgressBar').textContent = 'Complete!';
                
                alert('Video converted to hex successfully!');
            };
            
            reader.onerror = () => {
                alert('Error reading video file');
            };
            
            reader.readAsArrayBuffer(file);
        }
        
        function copyVideoHexToClipboard() {
            if (!videoHexData) {
                alert('Please convert a video to hex first');
                return;
            }
            navigator.clipboard.writeText(videoHexData).then(() => {
                alert('Video hex data copied to clipboard!');
            }).catch(() => {
                alert('Failed to copy to clipboard');
            });
        }
        
        function downloadVideoHexFile() {
            if (!videoHexData) {
                alert('Please convert a video to hex first');
                return;
            }
            const blob = new Blob([videoHexData], { type: 'text/plain' });
            const link = document.createElement('a');
            link.download = 'video-hex.txt';
            link.href = URL.createObjectURL(blob);
            link.click();
        }
        
        // HEX TO VIDEO CONVERSION
        document.getElementById('videoTxtUpload').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    document.getElementById('videoHexInput').value = e.target.result;
                };
                reader.readAsText(file);
            }
        });
        
        function convertHexToVideo() {
            const encodedHex = document.getElementById('videoHexInput').value.trim();
            if (!encodedHex) {
                alert('Please paste or upload hex data');
                return;
            }
            
            alert('Converting hex to video... This may take a moment.');
            
            setTimeout(() => {
                try {
                    // Decode the hex
                    const hex = decodeHex(encodedHex);
                    
                    // Convert hex to bytes
                    const bytes = new Uint8Array(hex.length / 2);
                    for (let i = 0; i < hex.length; i += 2) {
                        bytes[i / 2] = parseInt(hex.substr(i, 2), 16);
                    }
                    
                    // Create blob and load video
                    const blob = new Blob([bytes], { type: 'video/mp4' });
                    const url = URL.createObjectURL(blob);
                    const videoConverted = document.getElementById('videoPlayerConverted');
                    
                    videoConverted.src = url;
                    videoConverted.load();
                    
                    alert('Video converted successfully!');
                } catch (err) {
                    alert('Failed to convert hex to video: ' + err.message);
                }
            }, 100);
        }
        
        function downloadConvertedVideo() {
            const videoConverted = document.getElementById('videoPlayerConverted');
            if (!videoConverted.src) {
                alert('Please convert hex to video first');
                return;
            }
            
            const link = document.createElement('a');
            link.download = 'converted-video.mp4';
            link.href = videoConverted.src;
            link.click();
        }
        
        // ============================================
        // TEXT/CODE TO HEX CONVERSION
        // ============================================
        
        let textHexData = '';
        let decodedText = '';
        
        // Text file upload
        document.getElementById('textFileUpload').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    document.getElementById('textInput').value = e.target.result;
                };
                reader.readAsText(file);
            }
        });
        
        // Drag and drop for text upload
        const uploadAreaText = document.getElementById('uploadAreaText');
        uploadAreaText.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadAreaText.classList.add('dragover');
        });
        uploadAreaText.addEventListener('dragleave', () => {
            uploadAreaText.classList.remove('dragover');
        });
        uploadAreaText.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadAreaText.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    document.getElementById('textInput').value = e.target.result;
                };
                reader.readAsText(file);
            }
        });
        
        // Convert text to hex
        function convertTextToHex() {
            const text = document.getElementById('textInput').value;
            if (!text) {
                alert('Please enter or upload some text/code first');
                return;
            }
            
            // Convert text to UTF-8 bytes then to hex
            const encoder = new TextEncoder();
            const bytes = encoder.encode(text);
            let hex = '';
            
            for (let i = 0; i < bytes.length; i++) {
                hex += bytes[i].toString(16).padStart(2, '0');
            }
            
            // Apply character replacement (encoding)
            textHexData = encodeHex(hex);
            document.getElementById('textHexPreview').textContent = 
                textHexData.substring(0, 5000) + (textHexData.length > 5000 ? '...\n\n[' + textHexData.length + ' total characters]' : '');
            
            alert('Text/Code converted to hex successfully!');
        }
        
        function copyTextHexToClipboard() {
            if (!textHexData) {
                alert('Please convert text to hex first');
                return;
            }
            navigator.clipboard.writeText(textHexData).then(() => {
                alert('Hex data copied to clipboard!');
            }).catch(() => {
                alert('Failed to copy to clipboard');
            });
        }
        
        function downloadTextHexFile() {
            if (!textHexData) {
                alert('Please convert text to hex first');
                return;
            }
            const blob = new Blob([textHexData], { type: 'text/plain' });
            const link = document.createElement('a');
            link.download = 'text-hex.txt';
            link.href = URL.createObjectURL(blob);
            link.click();
        }
        
        // HEX TO TEXT/CODE CONVERSION
        
        // Hex text file upload
        document.getElementById('hexTextFileUpload').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    document.getElementById('hexToTextInput').value = e.target.result;
                };
                reader.readAsText(file);
            }
        });
        
        // Drag and drop for hex text upload
        const uploadAreaHexText = document.getElementById('uploadAreaHexText');
        uploadAreaHexText.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadAreaHexText.classList.add('dragover');
        });
        uploadAreaHexText.addEventListener('dragleave', () => {
            uploadAreaHexText.classList.remove('dragover');
        });
        uploadAreaHexText.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadAreaHexText.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    document.getElementById('hexToTextInput').value = e.target.result;
                };
                reader.readAsText(file);
            }
        });
        
        // Convert hex to text
        function convertHexToText() {
            const encodedHex = document.getElementById('hexToTextInput').value.trim();
            if (!encodedHex) {
                alert('Please paste or upload hex data');
                return;
            }
            
            try {
                // Decode the hex
                const hex = decodeHex(encodedHex);
                
                // Convert hex to bytes
                const bytes = new Uint8Array(hex.length / 2);
                for (let i = 0; i < hex.length; i += 2) {
                    bytes[i / 2] = parseInt(hex.substr(i, 2), 16);
                }
                
                // Decode UTF-8 bytes to text
                const decoder = new TextDecoder('utf-8');
                decodedText = decoder.decode(bytes);
                
                document.getElementById('decodedTextOutput').value = decodedText;
                alert('Hex converted to text successfully!');
            } catch (err) {
                alert('Failed to convert hex to text: ' + err.message);
            }
        }
        
        function copyDecodedText() {
            const text = document.getElementById('decodedTextOutput').value;
            if (!text) {
                alert('Please convert hex to text first');
                return;
            }
            navigator.clipboard.writeText(text).then(() => {
                alert('Text copied to clipboard!');
            }).catch(() => {
                alert('Failed to copy to clipboard');
            });
        }
        
        function downloadDecodedText() {
            const text = document.getElementById('decodedTextOutput').value;
            if (!text) {
                alert('Please convert hex to text first');
                return;
            }
            const blob = new Blob([text], { type: 'text/plain' });
            const link = document.createElement('a');
            link.download = 'decoded-text.txt';
            link.href = URL.createObjectURL(blob);
            link.click();
        }
    </script>
</body>
</html>
